# Entity (Tiene identidad)

Pregunta clave: "Â¿Tiene un ID Ãºnico y puede cambiar en el tiempo manteniendo su identidad?"

# Value Object (Se define por su valor)

Pregunta clave: "Â¿Se define completamente por sus atributos? Â¿Es inmutable?"

# Domain Service (LÃ³gica que no pertenece a ninguna Entity)

Pregunta clave: "Â¿Esta lÃ³gica involucra mÃºltiples entities o es un proceso del dominio que no encaja naturalmente en una entity?"

<!--  -->

# ğŸ¯ Resumen como checklist

Identidad estable (ID, historia, seguimiento)?
â†’ Entidad

Reemplazable por valores iguales, sin historia?
â†’ Value Object

Varias entidades/VO que deben cumplir reglas juntas, en la misma transacciÃ³n?
â†’ Agregado (elige raÃ­z)

Necesito consultar/persistir por separado?
â†’ Repository para la raÃ­z del agregado

# ğŸ”‘ Observaciones crÃ­ticas

<!-- - Agregado pequeÃ±o: -->

Compra NO contiene al Cliente ni al Producto, solo referencias (IDs) y snapshots.

Esto evita un mega-agregado que bloquee todo.

<!-- - Value Objects embebidos: -->

Email, Address, Money, PurchaseItem.

No llevan repositorio.

<!-- - Repositorios SOLO en raÃ­ces: -->

ClientRepository, ProductRepository, PurchaseRepository.

âŒ Nada como PurchaseItemRepository.

<!-- Invariantes claras por agregado: -->

Cliente: reglas sobre email, direcciones.

Producto: stock no puede ser negativo.

Compra: total = suma Ã­tems, no se puede pagar vacÃ­a.

# AsÃ­ se ve el flujo

Cliente hace una Compra.

Compra referencia a Producto y a Cliente por ID, guarda snapshots de Producto en PurchaseItem.

Si hay regla de stock, se coordina con Producto mediante evento/command, no metiendo Producto adentro del agregado Compra.
